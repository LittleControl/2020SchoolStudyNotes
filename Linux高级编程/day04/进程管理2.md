# 进程管理

## 等待子进程的退出——wait

当父进程需要等待子进程结束的时候,可以使用wait函数

- waitpid
  - 功能: 阻塞调用进程直到特定的子进程结束
  - 文件: `/usr/include/sys/wait.h`
  - 返回值: >0 子进程pid号 -1 出错 0 不阻塞调用进程时正常使用

## 进程退出

- 从main返回(return或隐含)
- 调用exit
- 调用_exit
- 最后一个线程从其启动例程返回
- 最后一个线程调用pthread_exit异常终止
- 调用abort
- 接受到一个信号并终止
- 最后一个线程对取消请求做出相应

### exit和_exit的区别

- _exit()执行后立即返回给内核,而exit()要先执行一些清除操作,然后将控制权交给内核
- 调用_exit函数时,其会关闭进程所有的的文件描述符,清理内存以及其他一些内核函数,但不会刷新流(stdin, stdout, stderrr ...). exit函数是在_exit函数之上的一个封装,其会调用_exit,并在调用之前先刷新流.
- exit()函数与_exit()函数最大区别就在于exit()函数在调用exit系统之前要检查文件的打开情况,把文件缓冲区的内容写回文件

### eixt完成的操作

- 关闭进程打开的所有文件描述符,目录描述符
- 将该进程子进程的PPID置为init进程的pid
- 如果父进程调用wait或waitpid来等待子进程结束,则通知父进程
- 向父进程发送SIGCHLD信号

### on_exit的作用

用来注册终止处理程序,当程序调用exit或者从main函数中返回时,调用注册的函数

## 僵尸进程和孤儿进程

### 僵尸进程(子进程先于父进程结束)

子进程先于父进程结束时,子进程将结束状态传递给exit函数,该状态被存放在内核空间中.  
之后子进程结束,释放内存空间,但一些存放进程属性的空间并未释放,此时进程处于僵死状态.   
如果父进程未使用wait,则进程将留在系统中,这种状态的子进程被称为僵尸进程.

- 僵尸进程占用了宝贵的系统资源:进程号
- 僵尸进程是一般进程必然要经历的一种状态

### 孤儿进程(父进程先于子进程结束)

- 失去父进程的进程——孤儿进程  
- 将被init进程接受
- 孤儿进程也是进程的一种临时状态

## 进程的属性

### 进程组

- 每个进程属于一个进程组,有进程组号,即进程组长的进程号
- 进程组是一个或多个进程的集合,通常与用一作业相关联,接受来自同一终端的各种信号.
- 进程组长可以创建要给进程组,可以创建该组中的进程
- 进程组存在与否与进程组长是否存在无关
- 可使用getpid获取进程组号,setpgid设置进程组号

### 会话

会话(session)是一个或多个进程组的集合

### 控制终端

## 守护进程

- 守护进程(Daemon)也成为精灵进程,是一类运行在后台,独立于控制终端,执行日常事务的特殊进程.通常在系统自举时启动,关闭时终止
- 守护进程周期性地执行某种任务或等待处理某些发生的事件,Linux的大多数服务都是用守护进程实现的

### 守护进程的编程要点

- 屏蔽一些有关控制终端的信号
  - 防止在守护进程没有正常运行起来前,受到控制终端的干扰退出或挂起
- 调用fork,然后使父进程退出,这么是为了保证一下两点:
  - 父进程退出,使系统不认为子进程是简单shell命令
  - 保证子进程不是进程组长,从而可以调用setsid产生新会话
- 脱离控制终端和进程组
  - 需要调用setsid使子进程成为新的会话组长
- 禁止进程重新打开控制终端
  - 为保证进程不会重新打开控制终端,就不可以给进程组长的身份,采用的方法是再次创建一个子进程,让父进程退出
- 关闭不需要的文件描述符,包括stdin,stdout,stderr
  - 如不关闭,会浪费系统资源,造成文件系统无法卸载等问题
- 改变当前工作目录
  - 进程活动时,其工作目录所在的文件系统不能卸载.因此,一般需要将守护进程的工作目录改变到其根目录
- 将文件模式创建屏蔽字设置为0
  - 从父进程继承来的文件模式创建模式,有可能会导致子进程无法读写文件,需要重设文件创建掩码
- 处理SIGCHLD信号(子进程退出信号)
  - 如果守护进程有生成子进程,无wait操作导致子进程成为僵尸进程而消耗系统资源.若守护进程选择调用wait操作,会加重自身的负担,影响服务器进程的并发性能.此时,忽略SIGCHLD信号可防止上述情况.
